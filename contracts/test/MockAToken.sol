// SPDX-License-Identifier: Apache-2.0

pragma solidity =0.8.9;

import "../interfaces/aave/IAaveV2LendingPool.sol";
import "../interfaces/aave/IAToken.sol";
import "../utils/WadRayMath.sol";
import "../utils/Printer.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract MockAToken is IAToken, ERC20 {
    using WadRayMath for uint256;
    IAaveV2LendingPool internal _pool;
    IERC20Minimal internal _underlyingAsset;

    modifier onlyLendingPool() {
        require(msg.sender == address(_pool), "CT_CALLER_MUST_BE_LENDING_POOL");
        _;
    }

    constructor(
        IAaveV2LendingPool pool,
        IERC20Minimal underlyingAsset,
        string memory name,
        string memory symbol
    ) ERC20(name, symbol) {
        _pool = pool;
        _underlyingAsset = underlyingAsset;
    }

    /**
     * @dev Calculates the balance of the user: principal balance + interest generated by the principal
     * @param user The user whose balance is calculated
     * @return The balance of the user
     **/
    function balanceOf(address user)
        public
        view
        override(ERC20)
        returns (uint256)
    {
        return
            super.balanceOf(user).rayMul(
                _pool.getReserveNormalizedIncome(_underlyingAsset)
            );
    }

    // AB: only lending pool modifier removed from the original AToken implementation
    /**
     * @dev Mints `amount` aTokens to `user`
     * - Only callable by the LendingPool, as extra state updates there need to be managed
     * @param user The address receiving the minted tokens
     * @param amount The amount of tokens getting minted
     * @param index The new liquidity index of the reserve
     * @return `true` if the the previous balance of the user was 0
     */
    function mint(
        address user,
        uint256 amount,
        uint256 index
    ) external returns (bool) {
        uint256 previousBalance = super.balanceOf(user);

        uint256 amountScaled = amount.rayDiv(index);

        require(amountScaled != 0, "CT_INVALID_MINT_AMOUNT");
        _mint(user, amountScaled);

        emit Transfer(address(0), user, amount);

        return previousBalance == 0;
    }

    /**
     * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`
     * - Only callable by the LendingPool, as extra state updates there need to be managed
     * @param user The owner of the aTokens, getting them burned
     * @param receiverOfUnderlying The address that will receive the underlying
     * @param amount The amount being burned
     * @param index The new liquidity index of the reserve
     **/
    function burn(
        address user,
        address receiverOfUnderlying,
        uint256 amount,
        uint256 index
    ) external override onlyLendingPool {
        uint256 amountScaled = amount.rayDiv(index);
        require(amountScaled != 0, "CT_INVALID_BURN_AMOUNT");
        _burn(user, amountScaled);

        // AB: changed from safeTransfer to transfer for simplicity
        IERC20Minimal(_underlyingAsset).transfer(receiverOfUnderlying, amount);

        emit Transfer(user, address(0), amount);
    }

    /**
     * @dev Transfers the aTokens between two users. Validates the transfer
     * (ie checks for valid HF after the transfer) if required
     * @param from The source address
     * @param to The destination address
     * @param amount The amount getting transferred
     **/
    // AB: removed validate parameter
    function _transfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        IERC20Minimal underlyingAsset = _underlyingAsset;
        IAaveV2LendingPool pool = _pool;

        uint256 index = pool.getReserveNormalizedIncome(underlyingAsset);

        super._transfer(from, to, amount.rayDiv(index));
    }

    function approveInternal(
        address owner,
        address spender,
        uint256 value
    ) public {
        _approve(owner, spender, value);
    }
}
